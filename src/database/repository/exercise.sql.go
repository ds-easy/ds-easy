// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: exercise.sql

package repository

import (
	"context"
)

const findAccessibleExercises = `-- name: FindAccessibleExercises :many
SELECT id, created_at, updated_at, deleted_at, exercise_name, exercise_path, lesson_id, uploaded_by, is_public
FROM exercises e
WHERE
  e.is_public = true OR e.uploaded_by = ?
`

func (q *Queries) FindAccessibleExercises(ctx context.Context, uploadedBy int64) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findAccessibleExercisesStmt, findAccessibleExercises, uploadedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAccessibleExercisesByLessonName = `-- name: FindAccessibleExercisesByLessonName :many
SELECT e.id, e.created_at, e.updated_at, e.deleted_at, e.exercise_name, e.exercise_path, e.lesson_id, e.uploaded_by, e.is_public
FROM exercises e
    LEFT JOIN lessons l ON e.lesson_id = l.id
WHERE
    l.lesson_name = ?
    AND (e.is_public = true OR (? IS NOT NULL AND e.uploaded_by = ?))
`

type FindAccessibleExercisesByLessonNameParams struct {
	LessonName string      `json:"lesson_name"`
	Column2    interface{} `json:"column_2"`
	UploadedBy int64       `json:"uploaded_by"`
}

func (q *Queries) FindAccessibleExercisesByLessonName(ctx context.Context, arg FindAccessibleExercisesByLessonNameParams) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findAccessibleExercisesByLessonNameStmt, findAccessibleExercisesByLessonName, arg.LessonName, arg.Column2, arg.UploadedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findExercises = `-- name: FindExercises :many
SELECT id, created_at, updated_at, deleted_at, exercise_name, exercise_path, lesson_id, uploaded_by, is_public FROM exercises
`

func (q *Queries) FindExercises(ctx context.Context) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findExercisesStmt, findExercises)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findExercisesByName = `-- name: FindExercisesByName :one
SELECT id, created_at, updated_at, deleted_at, exercise_name, exercise_path, lesson_id, uploaded_by, is_public FROM exercises WHERE exercises.exercise_name = ? LIMIT 1
`

func (q *Queries) FindExercisesByName(ctx context.Context, exerciseName string) (Exercise, error) {
	row := q.queryRow(ctx, q.findExercisesByNameStmt, findExercisesByName, exerciseName)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExerciseName,
		&i.ExercisePath,
		&i.LessonID,
		&i.UploadedBy,
		&i.IsPublic,
	)
	return i, err
}

const findPublicExercises = `-- name: FindPublicExercises :many
SELECT id, created_at, updated_at, deleted_at, exercise_name, exercise_path, lesson_id, uploaded_by, is_public FROM exercises WHERE is_public = true
`

func (q *Queries) FindPublicExercises(ctx context.Context) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findPublicExercisesStmt, findPublicExercises)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPublicExercisesByLessonName = `-- name: FindPublicExercisesByLessonName :many
SELECT e.id, e.created_at, e.updated_at, e.deleted_at, e.exercise_name, e.exercise_path, e.lesson_id, e.uploaded_by, e.is_public
FROM exercises e
    LEFT JOIN lessons l ON e.lesson_id = l.id
WHERE
    l.lesson_name = ? AND e.is_public = true
`

func (q *Queries) FindPublicExercisesByLessonName(ctx context.Context, lessonName string) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findPublicExercisesByLessonNameStmt, findPublicExercisesByLessonName, lessonName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findPublicExercisesByName = `-- name: FindPublicExercisesByName :one
SELECT id, created_at, updated_at, deleted_at, exercise_name, exercise_path, lesson_id, uploaded_by, is_public FROM exercises WHERE exercises.exercise_name = ? AND is_public = true LIMIT 1
`

func (q *Queries) FindPublicExercisesByName(ctx context.Context, exerciseName string) (Exercise, error) {
	row := q.queryRow(ctx, q.findPublicExercisesByNameStmt, findPublicExercisesByName, exerciseName)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExerciseName,
		&i.ExercisePath,
		&i.LessonID,
		&i.UploadedBy,
		&i.IsPublic,
	)
	return i, err
}

const findRandomAccessibleExercisesByLessonNameWithLimit = `-- name: FindRandomAccessibleExercisesByLessonNameWithLimit :many
SELECT e.id, e.created_at, e.updated_at, e.deleted_at, e.exercise_name, e.exercise_path, e.lesson_id, e.uploaded_by, e.is_public
FROM exercises e
    LEFT JOIN lessons l ON e.lesson_id = l.id
WHERE
    l.lesson_name = ?
    AND (e.is_public = true OR (? IS NOT NULL AND e.uploaded_by = ?))
ORDER BY RANDOM()
LIMIT ?
`

type FindRandomAccessibleExercisesByLessonNameWithLimitParams struct {
	LessonName string      `json:"lesson_name"`
	Column2    interface{} `json:"column_2"`
	UploadedBy int64       `json:"uploaded_by"`
	Limit      int64       `json:"limit"`
}

func (q *Queries) FindRandomAccessibleExercisesByLessonNameWithLimit(ctx context.Context, arg FindRandomAccessibleExercisesByLessonNameWithLimitParams) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findRandomAccessibleExercisesByLessonNameWithLimitStmt, findRandomAccessibleExercisesByLessonNameWithLimit,
		arg.LessonName,
		arg.Column2,
		arg.UploadedBy,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRandomPublicExercisesByLessonNameWithLimit = `-- name: FindRandomPublicExercisesByLessonNameWithLimit :many
SELECT e.id, e.created_at, e.updated_at, e.deleted_at, e.exercise_name, e.exercise_path, e.lesson_id, e.uploaded_by, e.is_public
FROM exercises e
    LEFT JOIN lessons l ON e.lesson_id = l.id
WHERE
    l.lesson_name = ? AND e.is_public = true
ORDER BY RANDOM()
LIMIT ?
`

type FindRandomPublicExercisesByLessonNameWithLimitParams struct {
	LessonName string `json:"lesson_name"`
	Limit      int64  `json:"limit"`
}

func (q *Queries) FindRandomPublicExercisesByLessonNameWithLimit(ctx context.Context, arg FindRandomPublicExercisesByLessonNameWithLimitParams) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findRandomPublicExercisesByLessonNameWithLimitStmt, findRandomPublicExercisesByLessonNameWithLimit, arg.LessonName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertExercise = `-- name: InsertExercise :one
INSERT INTO
    exercises (
        exercise_name,
        exercise_path,
        lesson_id,
        uploaded_by,
        is_public
    )
VALUES (?, ?, ?, ?, ?) RETURNING id, created_at, updated_at, deleted_at, exercise_name, exercise_path, lesson_id, uploaded_by, is_public
`

type InsertExerciseParams struct {
	ExerciseName string `json:"exercise_name"`
	ExercisePath string `json:"exercise_path"`
	LessonID     int64  `json:"lesson_id"`
	UploadedBy   int64  `json:"uploaded_by"`
	IsPublic     bool   `json:"is_public"`
}

func (q *Queries) InsertExercise(ctx context.Context, arg InsertExerciseParams) (Exercise, error) {
	row := q.queryRow(ctx, q.insertExerciseStmt, insertExercise,
		arg.ExerciseName,
		arg.ExercisePath,
		arg.LessonID,
		arg.UploadedBy,
		arg.IsPublic,
	)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExerciseName,
		&i.ExercisePath,
		&i.LessonID,
		&i.UploadedBy,
		&i.IsPublic,
	)
	return i, err
}
