// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: exercise.sql

package repository

import (
	"context"
)

const findExercises = `-- name: FindExercises :many
SELECT id, created_at, updated_at, deleted_at, exercise_name, exercise_path, lesson_id, uploaded_by FROM exercises
`

func (q *Queries) FindExercises(ctx context.Context) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findExercisesStmt, findExercises)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findExercisesByLessonName = `-- name: FindExercisesByLessonName :many
SELECT e.id, e.created_at, e.updated_at, e.deleted_at, e.exercise_name, e.exercise_path, e.lesson_id, e.uploaded_by
FROM exercises e
    LEFT JOIN lessons l ON e.lesson_id = l.id
WHERE
    l.lesson_name = ?
`

func (q *Queries) FindExercisesByLessonName(ctx context.Context, lessonName string) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findExercisesByLessonNameStmt, findExercisesByLessonName, lessonName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findExercisesByName = `-- name: FindExercisesByName :one
SELECT id, created_at, updated_at, deleted_at, exercise_name, exercise_path, lesson_id, uploaded_by FROM exercises WHERE exercises.exercise_name = ? LIMIT 1
`

func (q *Queries) FindExercisesByName(ctx context.Context, exerciseName string) (Exercise, error) {
	row := q.queryRow(ctx, q.findExercisesByNameStmt, findExercisesByName, exerciseName)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExerciseName,
		&i.ExercisePath,
		&i.LessonID,
		&i.UploadedBy,
	)
	return i, err
}

const findExercisesBySubject = `-- name: FindExercisesBySubject :many
SELECT e.id, e.created_at, e.updated_at, e.deleted_at, e.exercise_name, e.exercise_path, e.lesson_id, e.uploaded_by
FROM exercises e
    LEFT JOIN lessons l ON e.lesson_id = l.id
WHERE
    l.subject = ?
`

func (q *Queries) FindExercisesBySubject(ctx context.Context, subject string) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findExercisesBySubjectStmt, findExercisesBySubject, subject)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findRandomExercisesByLessonNameWithLimit = `-- name: FindRandomExercisesByLessonNameWithLimit :many
SELECT e.id, e.created_at, e.updated_at, e.deleted_at, e.exercise_name, e.exercise_path, e.lesson_id, e.uploaded_by
FROM exercises e
    LEFT JOIN lessons l ON e.lesson_id = l.id
WHERE
    l.lesson_name = ?
ORDER BY RANDOM()
LIMIT ?
`

type FindRandomExercisesByLessonNameWithLimitParams struct {
	LessonName string `json:"lesson_name"`
	Limit      int64  `json:"limit"`
}

func (q *Queries) FindRandomExercisesByLessonNameWithLimit(ctx context.Context, arg FindRandomExercisesByLessonNameWithLimitParams) ([]Exercise, error) {
	rows, err := q.query(ctx, q.findRandomExercisesByLessonNameWithLimitStmt, findRandomExercisesByLessonNameWithLimit, arg.LessonName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Exercise
	for rows.Next() {
		var i Exercise
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ExerciseName,
			&i.ExercisePath,
			&i.LessonID,
			&i.UploadedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertExercise = `-- name: InsertExercise :one
INSERT INTO
    exercises (
        exercise_name,
        exercise_path,
        lesson_id,
        uploaded_by
    )
VALUES (?, ?, ?, ?) RETURNING id, created_at, updated_at, deleted_at, exercise_name, exercise_path, lesson_id, uploaded_by
`

type InsertExerciseParams struct {
	ExerciseName string `json:"exercise_name"`
	ExercisePath string `json:"exercise_path"`
	LessonID     int64  `json:"lesson_id"`
	UploadedBy   int64  `json:"uploaded_by"`
}

func (q *Queries) InsertExercise(ctx context.Context, arg InsertExerciseParams) (Exercise, error) {
	row := q.queryRow(ctx, q.insertExerciseStmt, insertExercise,
		arg.ExerciseName,
		arg.ExercisePath,
		arg.LessonID,
		arg.UploadedBy,
	)
	var i Exercise
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ExerciseName,
		&i.ExercisePath,
		&i.LessonID,
		&i.UploadedBy,
	)
	return i, err
}
